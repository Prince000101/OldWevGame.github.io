<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minesweeper — Responsive & Touch</title>

  <!-- global theme / styles -->
  <link rel="stylesheet" href="../style.css">
  <script src="../assets/js/theme.js" defer></script>

  <style>
    /* keep page styles but variables from style.css will apply */
    :root { /* fallback */ }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#05060b,#0b1220);color:var(--white);display:flex;flex-direction:column;align-items:center}
    header{width:100%;max-width:1100px;padding:14px 18px;text-align:center}
    h1{margin:0;font-size:clamp(18px,3.6vw,28px)}
    p.subtitle{margin:6px 0 0;color:var(--muted);font-size:13px}
    main{width:100%;max-width:720px;padding:12px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;gap:12px}
    .panel{width:100%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .hud{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:8px;flex-wrap:wrap}
    .hud .left{display:flex;gap:12px;align-items:center}
    .btn{background:var(--accent);color:#071021;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:700}
    .muted{color:var(--muted);font-size:13px}
    #canvas-wrap{width:100%;display:flex;justify-content:center}
    canvas{background:#cfcfcf;border-radius:8px;display:block;touch-action:none}
    footer{width:100%;max-width:1100px;text-align:center;padding:10px 18px;color:var(--muted);font-size:13px}
    @media(max-width:420px){ .btn{padding:10px 12px} }
    /* simple legend */
    .legend{display:flex;gap:8px;align-items:center}
    .legend .box{width:18px;height:18px;border-radius:4px;border:2px solid rgba(0,0,0,0.15)}
  </style>
</head>
<body>
  <header>
    <h1>Minesweeper</h1>
    <p class="subtitle">Tap to reveal. Long-press (press & hold) to flag on touch devices. Right-click to flag on desktop.</p>
  </header>

  <main>
    <div class="panel">
      <div class="hud">
        <div class="left">
          <div class="muted">Mines left: <strong id="mines-left">0</strong></div>
          <div class="muted">Status: <strong id="status">Ready</strong></div>
        </div>
        <div style="display:flex;gap:8px">
          <select id="difficulty" style="padding:8px;border-radius:8px;background:#081224;color:var(--white);border:none">
            <option value="easy">Easy (8x8 - 10)</option>
            <option value="normal" selected>Normal (16x16 - 40)</option>
            <option value="hard">Hard (16x30 - 99)</option>
          </select>
          <button id="resetBtn" class="btn">Restart</button>
        </div>
      </div>

      <div id="canvas-wrap">
        <canvas id="board"></canvas>
      </div>
      <div style="margin-top:10px;color:var(--muted);font-size:13px">
        How to play: Reveal all safe tiles. Flag suspected mines. Long-press (touch) or right-click to place a flag.
      </div>
    </div>
  </main>

  <footer>Made with ❤️ — Rotate device to landscape for bigger board</footer>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const minesLeftEl = document.getElementById('mines-left');
  const resetBtn = document.getElementById('resetBtn');
  const difficultySel = document.getElementById('difficulty');
  const statusEl = document.getElementById('status');
  let rows = 16, cols = 16, minesCount = 40;

  function setDifficulty(mode){
    if(mode === 'easy'){ rows=8; cols=8; minesCount=10; }
    else if(mode === 'normal'){ rows=16; cols=16; minesCount=40; }
    else if(mode === 'hard'){ rows=16; cols=30; minesCount=99; }
  }
  setDifficulty(difficultySel.value);

  // responsive canvas sizing: fit parent width, keep square grid cell
  function resizeCanvas() {
    const wrap = document.getElementById('canvas-wrap');
    const maxW = Math.min(wrap.clientWidth, window.innerHeight * 0.7);
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    // compute cell size so board fits nicely
    const desiredWidth = Math.floor(maxW);
    canvas.style.width = desiredWidth + 'px';
    canvas.style.height = desiredWidth + 'px';
    canvas.width = desiredWidth * dpr;
    canvas.height = desiredWidth * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw(); // redraw after resize
  }
  window.addEventListener('resize', resizeCanvas, { passive:true });

  // game state
  let board = [];
  let revealedCount = 0;
  let flagsPlaced = 0;
  let firstClick = true;
  let gameOver = false;
  let longPressTimer = null;
  let longPressDuration = 500; // ms

  function initBoard(){
    board = [];
    revealedCount = 0;
    flagsPlaced = 0;
    gameOver = false;
    firstClick = true;
    statusEl.textContent = 'Ready';
    for(let r=0;r<rows;r++){
      const row = [];
      for(let c=0;c<cols;c++){
        row.push({ mine:false, revealed:false, flagged:false, adjacent:0 });
      }
      board.push(row);
    }
    updateMinesLeft();
    resizeCanvas();
  }

  function placeMines(excludeR, excludeC){
    let placed = 0;
    while(placed < minesCount){
      const r = Math.floor(Math.random()*rows);
      const c = Math.floor(Math.random()*cols);
      if(board[r][c].mine) continue;
      if(Math.abs(r-excludeR) <=1 && Math.abs(c-excludeC) <=1) continue;
      board[r][c].mine = true; placed++;
    }
  }

  function countAdj(){
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(board[r][c].mine){ board[r][c].adjacent = -1; continue; }
        let cnt = 0;
        for(let dr=-1;dr<=1;dr++){
          for(let dc=-1;dc<=1;dc++){
            if(dr===0&&dc===0) continue;
            const nr=r+dr, nc=c+dc;
            if(nr>=0&&nr<rows&&nc>=0&&nc<cols && board[nr][nc].mine) cnt++;
          }
        }
        board[r][c].adjacent = cnt;
      }
    }
  }

  function reveal(r,c){
    if(gameOver) return;
    if(r<0||r>=rows||c<0||c>=cols) return;
    const cell = board[r][c];
    if(cell.revealed || cell.flagged) return;
    cell.revealed = true; revealedCount++;
    if(cell.mine){
      gameOver = true; revealAllMines(); statusEl.textContent = 'BOOM!'; draw(); setTimeout(()=>alert('BOOM! You hit a mine.'),50); return;
    }
    if(cell.adjacent === 0){
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) {
        if(dr!==0||dc!==0) reveal(r+dr,c+dc);
      }
    }
    checkWin();
  }

  function revealAllMines(){
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(board[r][c].mine) board[r][c].revealed = true;
  }

  function toggleFlag(r,c){
    if(gameOver) return;
    const cell = board[r][c];
    if(cell.revealed) return;
    if(cell.flagged){ cell.flagged=false; flagsPlaced--; }
    else{ if(flagsPlaced>=minesCount) return; cell.flagged=true; flagsPlaced++; }
    updateMinesLeft();
  }

  function checkWin(){
    if(revealedCount === rows*cols - minesCount){
      gameOver = true; revealAllMines(); statusEl.textContent = 'You Win!'; draw(); setTimeout(()=>alert('Congratulations! You cleared the board!'),50);
    }
  }

  function updateMinesLeft(){ minesLeftEl.textContent = Math.max(0, minesCount - flagsPlaced); }

  // drawing
  function draw(){
    if(!ctx) return;
    const cssW = canvas.clientWidth;
    const cell = cssW / cols;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    ctx.fillStyle = '#bdbdbd';
    ctx.fillRect(0,0,cssW,cssW);
    ctx.font = (cell * 0.6) + 'px sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = c*cell, y = r*cell;
        const cellObj = board[r][c];
        // base
        if(cellObj.revealed){
          ctx.fillStyle = '#e7e7e7';
          ctx.fillRect(x,y,cell,cell);
          if(cellObj.mine){
            // mine
            ctx.fillStyle = '#900';
            ctx.beginPath(); ctx.arc(x+cell/2,y+cell/2,cell*0.28,0,Math.PI*2); ctx.fill();
          } else if(cellObj.adjacent>0){
            const colors = ['#0000FF','#006400','#FF0000','#000080','#800000','#008080','#000000','#808080'];
            ctx.fillStyle = colors[cellObj.adjacent-1] || '#000';
            ctx.fillText(cellObj.adjacent, x+cell/2, y+cell/2 + 1);
          }
        } else {
          // unrevealed look
          ctx.fillStyle = '#9e9e9e';
          ctx.fillRect(x,y,cell,cell);
          // slight top-left highlight
          ctx.strokeStyle = '#7b7b7b';
          ctx.beginPath(); ctx.moveTo(x,y+cell); ctx.lineTo(x,y); ctx.lineTo(x+cell,y); ctx.stroke();
          // flag
          if(cellObj.flagged){
            ctx.fillStyle = '#b00';
            ctx.beginPath();
            ctx.moveTo(x + cell*0.38, y + cell*0.76);
            ctx.lineTo(x + cell*0.62, y + cell*0.76);
            ctx.lineTo(x + cell*0.5, y + cell*0.46);
            ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#600'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(x + cell*0.5, y + cell*0.76); ctx.lineTo(x + cell*0.5, y + cell*0.28); ctx.stroke();
            ctx.lineWidth = 1;
          }
        }
        // border
        ctx.strokeStyle = '#8a8a8a';
        ctx.strokeRect(x+0.5,y+0.5,cell-1,cell-1);
      }
    }
  }

  // coordinate helpers
  function getCellFromEvent(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    const cssW = canvas.clientWidth;
    const c = Math.floor(mx / (cssW/cols));
    const r = Math.floor(my / (cssW/cols));
    return { r, c };
  }

  // pointer/ click handlers with long-press for flags
  canvas.addEventListener('pointerdown', e => {
    if(gameOver) return;
    (e.target).setPointerCapture && (e.target).setPointerCapture(e.pointerId);
    longPressTimer = setTimeout(() => {
      const { r, c } = getCellFromEvent(e.clientX, e.clientY);
      if(r>=0&&r<rows&&c>=0&&c<cols){ toggleFlag(r,c); draw(); }
      longPressTimer = null;
    }, longPressDuration);
  });

  canvas.addEventListener('pointerup', e => {
    if(longPressTimer){
      clearTimeout(longPressTimer); longPressTimer = null;
      const { r, c } = getCellFromEvent(e.clientX, e.clientY);
      if(r<0||r>=rows||c<0||c>=cols) return;
      // left click reveal
      if(firstClick){
        placeMines(r,c); countAdj(); firstClick=false;
      }
      reveal(r,c); draw();
    }
  });

  // right-click for flagging (desktop)
  canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    if(gameOver) return;
    const { r, c } = getCellFromEvent(e.clientX, e.clientY);
    if(r>=0&&r<rows&&c>=0&&c<cols){ toggleFlag(r,c); draw(); }
  });

  // reset and difficulty
  resetBtn.addEventListener('click', () => { setDifficulty(difficultySel.value); initBoard(); draw(); });
  difficultySel.addEventListener('change', () => { setDifficulty(difficultySel.value); initBoard(); draw(); });

  // initialisation
  setDifficulty(difficultySel.value);
  initBoard();
  // make sure canvas is sized after DOM/layout
  window.requestAnimationFrame(() => { resizeCanvas(); });

  // expose draw to resize observer
  const ro = new ResizeObserver(() => { resizeCanvas(); });
  ro.observe(document.getElementById('canvas-wrap'));
})();
</script>
</body>
</html>