<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Snake — Retro Arcade (Responsive & Touch)</title>

  <!-- global theme / styles -->
  <link rel="stylesheet" href="../style.css">
  <script src="../assets/js/theme.js" defer></script>

<style>
  :root{
    --bg:#071021;
    --panel:#0f1724;
    --accent:#ffcc33;
    --muted:#9aa4b2;
    --card:#0b1220;
    --white:#eef6ff;
    --danger:#ff6b6b;
    --success:#57d27a;
    --radius:12px;
  }

  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:
    radial-gradient(circle at 10% 10%, rgba(255,255,255,0.02), transparent 10%),
    linear-gradient(180deg,#03060b,#071021);color:var(--white);display:flex;align-items:center;justify-content:center;padding:16px}

  .wrap{
    width:100%;max-width:980px;
    display:grid;
    grid-template-columns: 1fr 320px;
    gap:18px;
    align-items:start;
  }

  @media (max-width:920px){
    .wrap{ grid-template-columns: 1fr; padding-bottom:12px; }
  }

  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    border-radius:var(--radius);
    padding:14px;
    box-shadow:0 12px 40px rgba(0,0,0,0.6);
  }

  header{ display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px }
  h1{font-size:clamp(18px,3.2vw,24px);margin:0}
  .muted{color:var(--muted);font-size:13px}

  /* canvas stage */
  .stage{
    background: #000;
    border-radius:10px;
    padding:12px;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  canvas{ display:block; width:100%; height:auto; image-rendering:pixelated; border-radius:6px; background:#000; touch-action:none; }

  /* right column */
  .sidebar{ display:flex; flex-direction:column; gap:12px; width:100%; }
  .info{ padding:12px; background:rgba(255,255,255,0.02); border-radius:10px; font-size:14px; color:var(--muted) }
  .stats{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
  .stat{ background:rgba(255,255,255,0.02); padding:8px 10px; border-radius:8px; font-weight:700 }

  .controls{ display:flex; gap:8px; flex-wrap:wrap; }
  .btn{ background:var(--accent); color:#071021; padding:8px 12px; border-radius:8px; border:0; cursor:pointer; font-weight:700 }
  .btn-ghost{ background:transparent; color:var(--white); border:1px solid rgba(255,255,255,0.04) }

  /* touch dpad overlay (mobile) */
  .dpad{
    position: absolute;
    left:18px;
    bottom:18px;
    width:132px;
    height:132px;
    display:grid;
    grid-template-columns:1fr 1fr 1fr;
    grid-template-rows:1fr 1fr 1fr;
    gap:8px;
    padding:8px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    touch-action: none;
  }
  .dpad button{ background:transparent;border:0;color:var(--white);font-weight:800;font-size:18px; border-radius:8px; cursor:pointer }
  .dpad .center{ opacity:0.4 }

  @media (min-width:921px){
    .dpad{ display:none }
  }

  /* How to play box */
  .howto{ font-size:13px; color:var(--muted); line-height:1.3 }

  .footer-note{ text-align:center; color:var(--muted); font-size:13px; margin-top:10px }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <header>
        <h1>Snake</h1>
        <div class="muted">Responsive • Touch • Keyboard</div>
      </header>

      <div class="stage" id="stage" style="position:relative">
        <canvas id="canvas" role="application" aria-label="Snake game"></canvas>

        <!-- touch D-pad for phones -->
        <div class="dpad" id="dpad" aria-hidden="false">
          <div></div><div><button id="btn-up">▲</button></div><div></div>
          <div><button id="btn-left">◀</button></div>
          <div class="center"><button id="btn-pause">●</button></div>
          <div><button id="btn-right">▶</button></div>
          <div></div><div><button id="btn-down">▼</button></div><div></div>
        </div>
      </div>

      <div class="footer-note">Tip: rotate your phone to landscape for a larger play area. Use arrows / WASD / swipe or on-screen D‑pad.</div>
    </div>

    <aside class="sidebar">
      <div class="panel info">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="stats">
            <div class="stat">Score: <span id="score">0</span></div>
            <div class="stat">High: <span id="high">0</span></div>
            <div class="stat">Speed: <span id="speedLabel">Normal</span></div>
          </div>
        </div>

        <div class="controls" style="margin-bottom:8px">
          <button id="start" class="btn">Start / Restart</button>
          <button id="btn-slow" class="btn-ghost">Easy</button>
          <button id="btn-normal" class="btn-ghost" aria-pressed="true">Normal</button>
          <button id="btn-fast" class="btn-ghost">Fast</button>
        </div>

        <div class="howto">
          How to play on phone:
          <ul style="margin:6px 0 0 18px;padding:0;color:var(--muted)">
            <li>Swipe anywhere on the board to change direction.</li>
            <li>Use the on-screen D‑pad if you prefer buttons.</li>
            <li>Avoid walls and your tail. Eat the red food to grow and score.</li>
          </ul>
        </div>
      </div>

      <div class="panel info">
        <div style="font-weight:700;margin-bottom:6px">Settings & Info</div>
        <div class="muted" style="margin-bottom:6px">Wrap mode: off (hitting walls ends the game). You can enable wrap by editing the file.</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="btn-toggle-wrap" class="btn-ghost">Wrap: Off</button>
        </div>
        <div style="margin-top:10px" class="muted">Controls: Arrow keys / WASD / swipe / D-pad. Tap the center D‑pad to pause.</div>
      </div>
    </aside>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const stage = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const speedLabel = document.getElementById('speedLabel');
  const startBtn = document.getElementById('start');
  const btnSlow = document.getElementById('btn-slow');
  const btnNormal = document.getElementById('btn-normal');
  const btnFast = document.getElementById('btn-fast');
  const btnWrap = document.getElementById('btn-toggle-wrap');
  const dpad = document.getElementById('dpad');
  const btnUp = document.getElementById('btn-up');
  const btnDown = document.getElementById('btn-down');
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');
  const btnPause = document.getElementById('btn-pause');

  // game config
  let cols = 20, rows = 20;            // logical grid
  let tile = 24;                       // will be computed per screen
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let wrapMode = false;                // toggleable
  let speedMode = 'normal';            // 'slow' 'normal' 'fast'
  let baseInterval = 120;              // ms per move at normal speed

  // state
  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let food = null;
  let score = 0;
  let high = parseInt(localStorage.getItem('snake-high') || '0', 10);
  let running = false;
  let paused = false;
  let lastTime = 0;
  let acc = 0;
  let moveInterval = baseInterval;
  let raf = null;

  // helpers
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function computeSizes(){
    // fit board to available stage width, leave room for HUD
    const maxW = Math.min(stage.clientWidth - 24, window.innerWidth - 48);
    const maxH = Math.max(200, window.innerHeight - 240);
    const size = Math.min(maxW, maxH);
    tile = Math.max(8, Math.floor(size / Math.max(cols, rows)));
    const cssWidth = tile * cols;
    const cssHeight = tile * rows;
    canvas.style.width = cssWidth + 'px';
    canvas.style.height = cssHeight + 'px';
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function setSpeed(mode){
    speedMode = mode;
    if(mode === 'slow'){ baseInterval = 160; speedLabel.textContent = 'Easy'; }
    else if(mode === 'normal'){ baseInterval = 120; speedLabel.textContent = 'Normal'; }
    else { baseInterval = 90; speedLabel.textContent = 'Fast'; }
    updateMoveInterval();
    // visual toggle
    btnSlow.setAttribute('aria-pressed', mode==='slow');
    btnNormal.setAttribute('aria-pressed', mode==='normal');
    btnFast.setAttribute('aria-pressed', mode==='fast');
  }

  function updateMoveInterval(){
    // speed scales with score so game gets harder slowly
    const speedUp = Math.floor(score / 50);
    moveInterval = Math.max(40, baseInterval - speedUp * 6);
  }

  function saveHigh(){
    if(score > high){ high = score; localStorage.setItem('snake-high', String(high)); highEl.textContent = high; }
  }

  function resetGame(){
    cols = 20; rows = 20; // could adapt to screen for advanced behavior
    snake = [];
    const sx = Math.floor(cols/2), sy = Math.floor(rows/2);
    snake.push({x:sx,y:sy});
    snake.push({x:sx-1,y:sy});
    snake.push({x:sx-2,y:sy});
    dir = {x:1,y:0}; nextDir = {x:1,y:0};
    placeFood();
    score = 0;
    updateMoveInterval();
    scoreEl.textContent = score;
    highEl.textContent = high;
    paused = false;
    running = true;
  }

  function placeFood(){
    let tries = 0;
    while(true){
      const f = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
      if(!snake.some(s => s.x === f.x && s.y === f.y)){ food = f; break; }
      if(++tries > 200) break;
    }
  }

  // game logic step
  function step(){
    // apply nextDir only if not reversing
    if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
      dir = {...nextDir};
    }
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    if(wrapMode){
      head.x = (head.x + cols) % cols;
      head.y = (head.y + rows) % rows;
    } else {
      if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows){
        return gameOver();
      }
    }

    // collision with self
    if(snake.some(s => s.x === head.x && s.y === head.y)) return gameOver();

    snake.unshift(head);

    // eat food
    if(food && head.x === food.x && head.y === food.y){
      score += 10;
      updateMoveInterval();
      placeFood();
      scoreEl.textContent = score;
      saveHigh();
    } else {
      snake.pop();
    }
  }

  function gameOver(){
    running = false;
    paused = false;
    saveHigh();
    draw();
    // show overlay text
    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, cssH/2 - 36, cssW, 72);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = Math.max(14, tile * 1.2) + 'px system-ui';
    ctx.fillText('Game Over — Press Start', cssW/2, cssH/2 + 8);
  }

  function draw(){
    const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cssW,cssH);

    // grid (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for(let x=0;x<=cols;x++){
      ctx.beginPath(); ctx.moveTo(x*tile+0.5, 0); ctx.lineTo(x*tile+0.5, cssH); ctx.stroke();
    }
    for(let y=0;y<=rows;y++){
      ctx.beginPath(); ctx.moveTo(0, y*tile+0.5); ctx.lineTo(cssW, y*tile+0.5); ctx.stroke();
    }

    // food
    if(food){
      ctx.fillStyle = 'red';
      const pad = Math.max(2, Math.floor(tile*0.12));
      ctx.fillRect(food.x*tile + pad, food.y*tile + pad, tile - pad*2, tile - pad*2);
    }

    // snake
    for(let i=snake.length-1;i>=0;i--){
      const s = snake[i];
      const x = s.x * tile, y = s.y * tile;
      if(i === 0){
        // head
        ctx.fillStyle = '#7CFC00';
        roundRect(ctx, x+1, y+1, tile-2, tile-2, Math.max(3,Math.floor(tile*0.18)), true, false);
      } else {
        ctx.fillStyle = i < 4 ? '#00c000' : '#0f6f0f';
        roundRect(ctx, x+1, y+1, tile-2, tile-2, Math.max(2,Math.floor(tile*0.12)), true, false);
      }
    }
  }

  // rounded rect helper
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
    ctx.beginPath();
    ctx.moveTo(x + r.tl, y);
    ctx.lineTo(x + w - r.tr, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    ctx.lineTo(x + w, y + h - r.br);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    ctx.lineTo(x + r.bl, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    ctx.lineTo(x, y + r.tl);
    ctx.quadraticCurveTo(x, y, x + r.tl, y);
    ctx.closePath();
    if(fill){ ctx.fill(); }
    if(stroke){ ctx.stroke(); }
  }

  // main loop with time accumulator for consistent stepping
  function loop(ts){
    if(!lastTime) lastTime = ts;
    const elapsed = ts - lastTime;
    lastTime = ts;
    if(running && !paused){
      acc += elapsed;
      while(acc >= moveInterval){
        step();
        acc -= moveInterval;
      }
    }
    draw();
    raf = requestAnimationFrame(loop);
  }

  // Input handling (keyboard)
  window.addEventListener('keydown', (e) => {
    if(['ArrowUp','w','W'].includes(e.key)){ requestDir(0,-1); }
    if(['ArrowDown','s','S'].includes(e.key)){ requestDir(0,1); }
    if(['ArrowLeft','a','A'].includes(e.key)){ requestDir(-1,0); }
    if(['ArrowRight','d','D'].includes(e.key)){ requestDir(1,0); }
    if(e.key === ' '){ // pause / resume
      paused = !paused;
    }
    // start on key press if not running
    if(!running && ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)){
      resetGame();
    }
  });

  function requestDir(x,y){
    // prevent immediate reverse
    if(x === -dir.x && y === -dir.y) return;
    nextDir = {x,y};
  }

  // Touch swipe detection
  let touchStart = null;
  canvas.addEventListener('pointerdown', (e) => {
    // allow dpad clicks as separate handlers
    touchStart = {x: e.clientX, y: e.clientY, t: performance.now()};
  }, {passive:false});
  canvas.addEventListener('pointermove', (e) => {
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x, dy = e.clientY - touchStart.y;
    if(Math.hypot(dx,dy) > 24){
      if(Math.abs(dx) > Math.abs(dy)){
        requestDir(dx < 0 ? -1 : 1, 0);
      } else {
        requestDir(0, dy < 0 ? -1 : 1);
      }
      touchStart = null;
      // start game on first swipe
      if(!running) resetGame();
    }
  }, {passive:false});
  canvas.addEventListener('pointerup', () => { touchStart = null; });

  // D‑pad & buttons
  function bindBtn(el, x,y){
    el.addEventListener('pointerdown', (e) => { e.preventDefault(); requestDir(x,y); if(!running) resetGame(); }, {passive:false});
    el.addEventListener('pointerup', (e) => { e.preventDefault(); }, {passive:false});
    el.addEventListener('pointercancel', () => {}, {passive:false});
  }
  bindBtn(btnUp, 0, -1);
  bindBtn(btnDown, 0, 1);
  bindBtn(btnLeft, -1, 0);
  bindBtn(btnRight, 1, 0);
  btnPause.addEventListener('pointerdown', (e) => { e.preventDefault(); paused = !paused; if(!running) resetGame(); }, {passive:false});

  // UI buttons
  startBtn.addEventListener('click', () => { resetGame(); });
  btnSlow.addEventListener('click', () => { setSpeed('slow'); });
  btnNormal.addEventListener('click', () => { setSpeed('normal'); });
  btnFast.addEventListener('click', () => { setSpeed('fast'); });
  btnWrap.addEventListener('click', () => {
    wrapMode = !wrapMode;
    btnWrap.textContent = 'Wrap: ' + (wrapMode ? 'On' : 'Off');
  });

  // init/responsiveness
  function onResize(){
    dpr = Math.max(1, window.devicePixelRatio || 1);
    computeSizes();
    draw();
  }
  window.addEventListener('resize', onResize);
  window.addEventListener('orientationchange', () => setTimeout(onResize, 120));

  // initialize
  highEl.textContent = high;
  setSpeed('normal');
  computeSizes();
  resetGame();
  // start RAF loop
  raf = requestAnimationFrame(loop);

  // cleanup on unload
  window.addEventListener('pagehide', () => { cancelAnimationFrame(raf); });

})();
</script>
</body>
</html>